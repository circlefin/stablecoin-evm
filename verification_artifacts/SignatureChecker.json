{"compiler":{"version":"0.6.12+commit.27d51765"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"address","name":"signer","type":"address"},{"internalType":"bytes32","name":"digest","type":"bytes32"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"isValidSignatureNow","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}],"devdoc":{"details":"Signature verification helper that can be used instead of `ECRecover.recover` to seamlessly support both ECDSA signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets. Adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/21bb89ef5bfc789b9333eb05e3ba2b7b284ac77c/contracts/utils/cryptography/SignatureChecker.sol","kind":"dev","methods":{"isValidSignatureNow(address,bytes32,bytes)":{"details":"Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECRecover.recover`.","params":{"digest":"Keccak-256 hash digest of the signed message","signature":"Signature byte array associated with hash","signer":"Address of the claimed signer"}}},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"compilationTarget":{"contracts/util/SignatureChecker.sol":"SignatureChecker"},"evmVersion":"istanbul","libraries":{},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":true,"runs":10000000},"remappings":[]},"sources":{"contracts/interface/IERC1271.sol":{"content":"/**\n * Copyright 2023 Circle Internet Financial, LTD. All rights reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.6.12;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash          Hash of the data to be signed\n     * @param signature     Signature byte array associated with the provided data hash\n     * @return magicValue   bytes4 magic value 0x1626ba7e when function passes\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature)\n        external\n        view\n        returns (bytes4 magicValue);\n}\n","keccak256":"0x8accb9f93dcd398e5c84cb80010de808cf5092cebfa823b3d7c4b8e5b2bcf672","license":"Apache-2.0"},"contracts/util/ECRecover.sol":{"content":"/**\n * Copyright 2023 Circle Internet Financial, LTD. All rights reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.6.12;\n\n/**\n * @title ECRecover\n * @notice A library that provides a safe ECDSA recovery function\n */\nlibrary ECRecover {\n    /**\n     * @notice Recover signer's address from a signed message\n     * @dev Adapted from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/65e4ffde586ec89af3b7e9140bdc9235d1254853/contracts/cryptography/ECDSA.sol\n     * Modifications: Accept v, r, and s as separate arguments\n     * @param digest    Keccak-256 hash digest of the signed message\n     * @param v         v of the signature\n     * @param r         r of the signature\n     * @param s         s of the signature\n     * @return Signer address\n     */\n    function recover(\n        bytes32 digest,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (\n            uint256(s) >\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n        ) {\n            revert(\"ECRecover: invalid signature 's' value\");\n        }\n\n        if (v != 27 && v != 28) {\n            revert(\"ECRecover: invalid signature 'v' value\");\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(digest, v, r, s);\n        require(signer != address(0), \"ECRecover: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @notice Recover signer's address from a signed message\n     * @dev Adapted from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/0053ee040a7ff1dbc39691c9e67a69f564930a88/contracts/utils/cryptography/ECDSA.sol\n     * @param digest    Keccak-256 hash digest of the signed message\n     * @param signature Signature byte array associated with hash\n     * @return Signer address\n     */\n    function recover(bytes32 digest, bytes memory signature)\n        internal\n        pure\n        returns (address)\n    {\n        require(signature.length == 65, \"ECRecover: invalid signature length\");\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n        return recover(digest, v, r, s);\n    }\n}\n","keccak256":"0xedf59af6c5998f9e4b0791cd79122a759a1d80a38453053df77838914dd1294d","license":"Apache-2.0"},"contracts/util/SignatureChecker.sol":{"content":"/**\n * Copyright 2023 Circle Internet Financial, LTD. All rights reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.6.12;\n\nimport { ECRecover } from \"./ECRecover.sol\";\nimport { IERC1271 } from \"../interface/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECRecover.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets.\n *\n * Adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/21bb89ef5bfc789b9333eb05e3ba2b7b284ac77c/contracts/utils/cryptography/SignatureChecker.sol\n */\nlibrary SignatureChecker {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECRecover.recover`.\n     * @param signer        Address of the claimed signer\n     * @param digest        Keccak-256 hash digest of the signed message\n     * @param signature     Signature byte array associated with hash\n     */\n    function isValidSignatureNow(\n        address signer,\n        bytes32 digest,\n        bytes memory signature\n    ) external view returns (bool) {\n        if (!isContract(signer)) {\n            return ECRecover.recover(digest, signature) == signer;\n        }\n        return isValidERC1271SignatureNow(signer, digest, signature);\n    }\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\n     * against the signer smart contract using ERC1271.\n     * @param signer        Address of the claimed signer\n     * @param digest        Keccak-256 hash digest of the signed message\n     * @param signature     Signature byte array associated with hash\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidERC1271SignatureNow(\n        address signer,\n        bytes32 digest,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeWithSelector(\n                IERC1271.isValidSignature.selector,\n                digest,\n                signature\n            )\n        );\n        return (success &&\n            result.length >= 32 &&\n            abi.decode(result, (bytes32)) ==\n            bytes32(IERC1271.isValidSignature.selector));\n    }\n\n    /**\n     * @dev Checks if the input address is a smart contract.\n     */\n    function isContract(address addr) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}\n","keccak256":"0x89181a5d7440ce21492c5023ab98357c76e3de81ffc376dfda3983997a70728a","license":"Apache-2.0"}},"version":1}